
# 构造函数的继承

**参考文档：**

[文档1](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html)
[文档2](http://yanhaijing.com/javascript/2014/11/09/object-inherit-of-js/)
[文档3](http://www.infoq.com/cn/articles/javascript-instantiation-and-inheritance)

[文档1-2](http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html)
[文档2-2](http://yanhaijing.com/javascript/2013/08/23/javascript-inheritance-how-to-shoot-yourself-in-the-foot-with-prototypes/)
[文档2-3](http://yanhaijing.com/javascript/2016/07/24/prototype-and-inheritance-of-js/)


# 继承方式

### 1. 借用构造函数(call, apply)

```js
function Student(arg1, arg2) {
	People.call(this, arg1);
	this.arg = arg2;
}
```

**弊端**

> 无法继承原型上的属性和方法;





### 2. prototype模式

```js
Student.prototype = new People();

//上面的方法会让 Student.prototype.constructor 指向 People
Student.prototype.constructor = Student;
```

**弊端**

> 1.子类无法继承父类的实例属性  
> 2.将父类的实例属性，扩展到子类的原型上  
> 3.修改了子类的原型属性，会导致 Student 上获取constructor属性为People，而不是Student  
> // (任何一个prototype对象都有一个constructor属性，指向它的构造函数)


### 3. 共享原型

```js
Student.prototype = People.prototype;

// 同2
Student.prototype.constructor = Student;
```

**弊端**

> 1.在Student的原型上扩展方法(或修改)，同时也会扩展到People的原型上
> 2.Student 原型上的constructor属性被指向 People




### 4. 临时构造函数

```js
function F() {
}

F.prototype = People.prototype;

Student.prototype = new F();

Student.prorotype.constructor = Student;

// 这样就可以Student的原型上扩展子构造函数的方法，同时不影响父构造函数的原形了。
// 在修复一下constructor属性就ok啦

Student.prorotype.constructor = Student;
```


### 4. 圣杯

```js
function extend(Child, Parent) {　　　　
	var F = function() {};
	F.prototype = Parent.prototype;
	Child.prototype = new F();
	Child.prototype.constructor = Child;
	Child.uber = Parent.prototype;
}

// 使用 方法如下：
extend(Cat, Animal);　
var cat1 = new Cat("大毛", "黄色");　
alert(cat1.species); // 动物

```

> 这个extend函数，就是YUI库如何实现继承的方法。  
> 另外，说明一点，函数体最后一行

```js
Child.uber = Parent.prototype;
```

> 意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是"向上"、"上一层"。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。


### 5. 拷贝继承















/*****
第一种：构造函数绑定，即用call(apply)把父对象的this指向改为子对象
缺点：不能继承原型上的属性和方法;

第二种：prototype模式，即把子对象的prototype对象指向Animal的一个实例;
缺点：如果子对象的prototype对象上有属性或方法时，将被清除;
注意：当改了prototype对象的constructor时，记得改回来，否则将造成继承链紊乱;

第三种：直接继承prototype，即child.prototype = parent.prototype;
优点：相比第二种效率更高，比较省内存;
缺点：如果子对象的prototype对象上有属性或方法时，将被清除;
且子对象的prototype对象修改后父对象的prototype也会被修改;

第四种：利用空对象作为中介，第三种的升级版;
缺点：如果子对象的prototype对象上有属性或方法时，将被清除;
且子对象的prototype对象修改后父对象的prototype也会被修改;

第五种：拷贝继承
缺点：只能继承原型上的属性和方法;
优点：如果子对象的prototype对象上有属性或方法时，不会被清除,
且子对象的prototype对象修改后父对象的prototype不会被修改;
总结：继承加在原型上的属性和方法时用第五种，而继承写在构造函数里的属性和方法则用第一种，两则结合用
/*****
